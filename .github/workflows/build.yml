name: Build packages

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    container: archlinux:base-devel

    steps:
      - uses: actions/checkout@v6

      - name: Setup build environment
        run: |
          # Update system and install dependencies
          pacman -Syu --noconfirm
          pacman -S --noconfirm npm fuse2 zlib github-cli

          # Create non-root builder user
          useradd -m builder
          echo "builder ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
          chown -R builder:builder .

      - name: Detect and validate packages
        id: changes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Auto-detect all packages (directories containing PKGBUILD)
          ALL_PACKAGES=$(find . -maxdepth 2 -name PKGBUILD -printf '%h\n' | sed 's|^\./||' | sort | tr '\n' ' ' | xargs)
          echo "All packages: $ALL_PACKAGES"
          echo "all=$ALL_PACKAGES" >> $GITHUB_OUTPUT

          # Validate: directory name must match pkgname
          ERRORS=0
          for pkg in $ALL_PACKAGES; do
            pkgname=$(grep '^pkgname=' "$pkg/PKGBUILD" | cut -d'=' -f2)
            if [ "$pkg" != "$pkgname" ]; then
              echo "ERROR: Directory '$pkg' does not match pkgname '$pkgname'"
              ERRORS=$((ERRORS + 1))
            fi
          done
          if [ $ERRORS -gt 0 ]; then
            echo "Validation failed: directory names must match pkgname in PKGBUILD"
            exit 1
          fi

          # Get list of changed files via GitHub CLI
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED=$(gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json files -q '.files[].path')
          else
            CHANGED=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }} --jq '.files[].filename')
          fi

          # Determine which packages changed
          PACKAGES=""
          for pkg in $ALL_PACKAGES; do
            if echo "$CHANGED" | grep -q "^${pkg}/" || [ -z "$CHANGED" ]; then
              PACKAGES="$PACKAGES $pkg"
            fi
          done

          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
          echo "Changed packages:$PACKAGES"

      - name: Download database and detect deletions
        id: database
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          mkdir -p repo
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/download/latest"
          curl -sL -f "${RELEASE_URL}/m-wells.db.tar.gz" -o repo/m-wells.db.tar.gz || echo "No existing database"
          curl -sL -f "${RELEASE_URL}/m-wells.files.tar.gz" -o repo/m-wells.files.tar.gz || true

          # Detect deleted packages
          REMOVED=""
          if [ -f repo/m-wells.db.tar.gz ]; then
            DB_PACKAGES=$(tar -tzf repo/m-wells.db.tar.gz | grep -oP '^[^/]+(?=/)' | sed 's/-[^-]*-[^-]*$//' | sort -u)
            for dbpkg in $DB_PACKAGES; do
              if ! echo "${{ steps.changes.outputs.all }}" | grep -qw "$dbpkg"; then
                REMOVED="$REMOVED $dbpkg"
              fi
            done
          fi
          echo "removed=$REMOVED" >> $GITHUB_OUTPUT

          # Determine if there's any work to do
          if [ -n "$REMOVED" ] || [ -n "${{ steps.changes.outputs.packages }}" ]; then
            echo "has_work=true" >> $GITHUB_OUTPUT
            echo "Work to do: removed='$REMOVED', packages='${{ steps.changes.outputs.packages }}'"
          else
            echo "has_work=false" >> $GITHUB_OUTPUT
            echo "Nothing to do, skipping remaining steps"
          fi

      - name: Import GPG key
        if: steps.changes.outputs.packages != '' || steps.database.outputs.has_work == 'true'
        run: echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

      - name: Remove deleted packages from database
        if: steps.database.outputs.removed != ''
        run: |
          echo "Removing deleted packages:${{ steps.database.outputs.removed }}"
          repo-remove --sign --key ${{ secrets.GPG_KEY_ID }} repo/m-wells.db.tar.gz ${{ steps.database.outputs.removed }}

      - name: Build changed packages
        if: steps.changes.outputs.packages != ''
        run: |
          for pkg in ${{ steps.changes.outputs.packages }}; do
            if [ -d "$pkg" ]; then
              echo "==> Building $pkg"
              su builder -c "cd $pkg && makepkg -s --noconfirm"
            fi
          done

      - name: Sign packages and update repo database
        if: steps.changes.outputs.packages != ''
        run: |
          # Copy and sign newly built packages
          for pkgdir in ${{ steps.changes.outputs.packages }}; do
            for pkg in "$pkgdir"/*.pkg.tar.zst; do
              if [ -f "$pkg" ]; then
                cp "$pkg" repo/
                gpg --batch --yes --detach-sign --no-armor "repo/$(basename $pkg)"
              fi
            done
          done

          # Rename files with colons (GitHub converts : to . in asset names)
          for f in repo/*:*; do
            [ -f "$f" ] && mv "$f" "$(echo $f | tr ':' '.')"
          done

          # Update repo database
          cd repo
          repo-add --sign --key ${{ secrets.GPG_KEY_ID }} m-wells.db.tar.gz *.pkg.tar.zst

      - name: Upload to release
        if: steps.database.outputs.has_work == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create release if it doesn't exist
          gh release view latest --repo ${{ github.repository }} || \
            gh release create latest --repo ${{ github.repository }} --title "Packages" --notes "Arch Linux binary packages"

          # Delete assets for removed packages
          for pkg in ${{ steps.database.outputs.removed }}; do
            echo "Deleting assets for removed package: $pkg"
            gh release view latest --repo ${{ github.repository }} --json assets -q '.assets[].name' | \
              grep "^${pkg}-" | while read -r asset; do
                gh release delete-asset latest "$asset" --repo ${{ github.repository }} --yes
              done
          done

          # Upload files, overwriting any existing
          gh release upload latest repo/* --repo ${{ github.repository }} --clobber
