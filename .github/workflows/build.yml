name: Build packages

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    container: archlinux:base-devel

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      - name: Setup build environment
        run: |
          # Update system and install dependencies
          pacman -Syu --noconfirm
          pacman -S --noconfirm npm fuse2 zlib

          # Create non-root builder user
          useradd -m builder
          echo "builder ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
          chown -R builder:builder .

      - name: Import GPG key
        run: echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

      - name: Detect and validate packages
        id: changes
        run: |
          # Auto-detect all packages (directories containing PKGBUILD)
          ALL_PACKAGES=$(find . -maxdepth 2 -name PKGBUILD -printf '%h\n' | sed 's|^\./||' | sort | tr '\n' ' ' | xargs)
          echo "All packages: $ALL_PACKAGES"
          echo "all=$ALL_PACKAGES" >> $GITHUB_OUTPUT

          # Validate: directory name must match pkgname
          ERRORS=0
          for pkg in $ALL_PACKAGES; do
            pkgname=$(grep '^pkgname=' "$pkg/PKGBUILD" | cut -d'=' -f2)
            if [ "$pkg" != "$pkgname" ]; then
              echo "ERROR: Directory '$pkg' does not match pkgname '$pkgname'"
              ERRORS=$((ERRORS + 1))
            fi
          done
          if [ $ERRORS -gt 0 ]; then
            echo "Validation failed: directory names must match pkgname in PKGBUILD"
            exit 1
          fi

          # Get list of changed files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          else
            CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          fi

          # Determine which packages changed
          PACKAGES=""
          for pkg in $ALL_PACKAGES; do
            if echo "$CHANGED" | grep -q "^${pkg}/" || [ -z "$CHANGED" ]; then
              PACKAGES="$PACKAGES $pkg"
            fi
          done

          # If workflow file changed, rebuild all
          if echo "$CHANGED" | grep -q "^\.github/"; then
            PACKAGES="$ALL_PACKAGES"
          fi

          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
          echo "Changed packages:$PACKAGES"

      - name: Download existing packages
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          mkdir -p existing

          # Get list of assets from latest release
          ASSETS=$(curl -sL "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest" | \
            grep '"name":' | grep '\.pkg\.tar\.zst' | sed 's/.*"name": "\(.*\)".*/\1/')

          RELEASE_URL="https://github.com/${{ github.repository }}/releases/download/latest"

          for pkg in ${{ steps.changes.outputs.all }}; do
            if ! echo "${{ steps.changes.outputs.packages }}" | grep -q "$pkg"; then
              echo "Downloading existing $pkg packages..."
              for asset in $ASSETS; do
                if echo "$asset" | grep -q "^${pkg}"; then
                  echo "  -> $asset"
                  curl -sL -f "${RELEASE_URL}/${asset}" -o "existing/${asset}" || true
                fi
              done
            fi
          done
          ls -la existing/ 2>/dev/null || echo "No existing packages to download"

      - name: Build changed packages
        run: |
          for pkg in ${{ steps.changes.outputs.packages }}; do
            if [ -d "$pkg" ]; then
              echo "==> Building $pkg"
              su builder -c "cd $pkg && makepkg -s --noconfirm"
            fi
          done

      - name: Sign packages and create repo
        run: |
          mkdir -p repo

          # Copy existing unchanged packages (already signed)
          if [ -d existing ] && [ "$(ls -A existing 2>/dev/null)" ]; then
            cp existing/*.pkg.tar.zst repo/ 2>/dev/null || true
            cp existing/*.pkg.tar.zst.sig repo/ 2>/dev/null || true
          fi

          # Copy and sign newly built packages
          for pkg in */*.pkg.tar.zst; do
            if [ -f "$pkg" ]; then
              cp "$pkg" repo/
              gpg --batch --yes --detach-sign --no-armor "repo/$(basename $pkg)"
            fi
          done

          # Rename files with colons (GitHub converts : to . in asset names)
          for pkg in repo/*:*; do
            [ -f "$pkg" ] && mv "$pkg" "$(echo $pkg | tr ':' '.')"
          done

          # Create and sign repo database
          cd repo
          repo-add --sign --key ${{ secrets.GPG_KEY_ID }} m-wells.db.tar.gz *.pkg.tar.zst

      - name: Delete outdated assets
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          pacman -S --noconfirm jq

          # Get release info
          RELEASE_DATA=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest")

          RELEASE_ID=$(echo "$RELEASE_DATA" | jq -r '.id // empty')

          if [ -z "$RELEASE_ID" ]; then
            echo "No existing release found"
            exit 0
          fi

          echo "Found release ID: $RELEASE_ID"

          # Delete assets that will be replaced
          for file in repo/*; do
            filename=$(basename "$file")
            ASSET_ID=$(echo "$RELEASE_DATA" | jq -r --arg name "$filename" '.assets[] | select(.name == $name) | .id // empty')
            if [ -n "$ASSET_ID" ]; then
              echo "Deleting old asset: $filename"
              curl -s -X DELETE -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/releases/assets/$ASSET_ID"
            fi
          done

      - name: Upload to release
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest
          files: repo/*
          token: ${{ secrets.GITHUB_TOKEN }}
