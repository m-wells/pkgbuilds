name: Build packages

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Rebuild all packages'
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    container: archlinux:base-devel

    steps:
      - uses: actions/checkout@v6

      - name: Setup build environment
        run: |
          # Update system and install dependencies
          pacman -Syu --noconfirm
          pacman -S --noconfirm npm fuse2 zlib github-cli

          # Create non-root builder user
          useradd -m builder
          echo "builder ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
          chown -R builder:builder .

      - name: Detect and validate packages
        id: changes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Auto-detect all packages (directories containing PKGBUILD)
          ALL_PACKAGES=$(find . -maxdepth 2 -name PKGBUILD -printf '%h\n' | sed 's|^\./||' | sort | tr '\n' ' ' | xargs)
          echo "All packages: $ALL_PACKAGES"
          echo "all=$ALL_PACKAGES" >> $GITHUB_OUTPUT

          # Validate: directory name must match pkgname
          ERRORS=0
          for pkg in $ALL_PACKAGES; do
            pkgname=$(grep '^pkgname=' "$pkg/PKGBUILD" | cut -d'=' -f2)
            if [ "$pkg" != "$pkgname" ]; then
              echo "ERROR: Directory '$pkg' does not match pkgname '$pkgname'"
              ERRORS=$((ERRORS + 1))
            fi
          done
          if [ $ERRORS -gt 0 ]; then
            echo "Validation failed: directory names must match pkgname in PKGBUILD"
            exit 1
          fi

          # Get list of changed files via GitHub CLI
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED=$(gh pr view ${{ github.event.pull_request.number }} --repo ${{ github.repository }} --json files -q '.files[].path')
          else
            CHANGED=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }} --jq '.files[].filename')
          fi

          # Determine which packages to build
          if [ "${{ inputs.force_rebuild }}" = "true" ]; then
            PACKAGES="$ALL_PACKAGES"
            echo "Force rebuild: building all packages"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PACKAGES=""
            echo "Manual trigger without force rebuild: no packages to build"
          else
            PACKAGES=""
            for pkg in $ALL_PACKAGES; do
              if echo "$CHANGED" | grep -q "^${pkg}/" || [ -z "$CHANGED" ]; then
                PACKAGES="$PACKAGES $pkg"
              fi
            done
            echo "Changed packages:$PACKAGES"
          fi

          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT

      - name: Download database and detect deletions
        id: database
        if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p repo
          gh release download latest --repo ${{ github.repository }} --pattern 'm-wells.db.tar.gz' --dir repo || echo "No existing database"
          gh release download latest --repo ${{ github.repository }} --pattern 'm-wells.files.tar.gz' --dir repo || true

          # Detect deleted packages
          REMOVED=""
          if [ -f repo/m-wells.db.tar.gz ]; then
            DB_PACKAGES=$(tar -tzf repo/m-wells.db.tar.gz | grep -oP '^[^/]+(?=/)' | sed 's/-[^-]*-[^-]*$//' | sort -u)
            for dbpkg in $DB_PACKAGES; do
              if ! echo "${{ steps.changes.outputs.all }}" | grep -qw "$dbpkg"; then
                REMOVED="$REMOVED $dbpkg"
              fi
            done
          fi
          echo "removed=$REMOVED" >> $GITHUB_OUTPUT

          # Determine if there's any work to do
          if [ -n "$REMOVED" ] || [ -n "${{ steps.changes.outputs.packages }}" ]; then
            echo "has_work=true" >> $GITHUB_OUTPUT
            echo "Work to do: removed='$REMOVED', packages='${{ steps.changes.outputs.packages }}'"
          else
            echo "has_work=false" >> $GITHUB_OUTPUT
            echo "Nothing to do, skipping remaining steps"
          fi

      - name: Import GPG key
        if: steps.changes.outputs.packages != '' || steps.database.outputs.has_work == 'true'
        run: echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

      - name: Remove deleted packages from database
        if: steps.database.outputs.removed != ''
        run: |
          echo "Removing deleted packages:${{ steps.database.outputs.removed }}"
          repo-remove --sign --key ${{ secrets.GPG_KEY_ID }} repo/m-wells.db.tar.gz ${{ steps.database.outputs.removed }}

      - name: Build changed packages
        id: build
        if: steps.changes.outputs.packages != ''
        run: |
          FAILED=""
          for pkg in ${{ steps.changes.outputs.packages }}; do
            if [ -d "$pkg" ]; then
              echo "==> Building $pkg"
              if ! su builder -c "cd $pkg && makepkg -s --noconfirm"; then
                echo "::error::Failed to build $pkg"
                FAILED="$FAILED $pkg"
              fi
            fi
          done
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          if [ -n "$FAILED" ]; then
            echo "Failed packages:$FAILED"
          fi

      - name: Smoke test packages
        if: steps.changes.outputs.packages != ''
        run: |
          for pkgdir in ${{ steps.changes.outputs.packages }}; do
            for pkg in "$pkgdir"/*.pkg.tar.zst; do
              [ -f "$pkg" ] || continue
              echo "==> Testing $pkg"
              pacman -U --noconfirm "$pkg"
            done

            # Package-specific smoke tests
            case "$pkgdir" in
              gemini-cli)
                gemini-cli --version
                ;;
              rpi-imager)
                # GUI app - just verify binary is executable
                test -x /opt/rpi-imager/rpi-imager.AppImage
                ;;
            esac
          done

      - name: Sign packages and update repo database
        if: steps.changes.outputs.packages != ''
        run: |
          # Copy and sign newly built packages
          for pkgdir in ${{ steps.changes.outputs.packages }}; do
            for pkg in "$pkgdir"/*.pkg.tar.zst; do
              if [ -f "$pkg" ]; then
                cp "$pkg" repo/
                gpg --batch --yes --detach-sign --no-armor "repo/$(basename $pkg)"
              fi
            done
          done

          # Rename files with colons (GitHub converts : to . in asset names)
          for f in repo/*:*; do
            [ -f "$f" ] && mv "$f" "$(echo $f | tr ':' '.')"
          done

          # Update repo database
          cd repo
          if ls *.pkg.tar.zst 1>/dev/null 2>&1; then
            repo-add --sign --key ${{ secrets.GPG_KEY_ID }} m-wells.db.tar.gz *.pkg.tar.zst
          fi

      - name: Upload to release
        if: steps.database.outputs.has_work == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create release if it doesn't exist
          gh release view latest --repo ${{ github.repository }} || \
            gh release create latest --repo ${{ github.repository }} --title "Packages" --notes "Arch Linux binary packages"

          # Delete assets for removed packages
          for pkg in ${{ steps.database.outputs.removed }}; do
            echo "Deleting assets for removed package: $pkg"
            gh release view latest --repo ${{ github.repository }} --json assets -q '.assets[].name' | \
              grep "^${pkg}-" | while read -r asset; do
                gh release delete-asset latest "$asset" --repo ${{ github.repository }} --yes
              done
          done

          # Delete old assets for updated packages (before uploading new versions)
          for file in repo/*.pkg.tar.zst; do
            [ -f "$file" ] || continue
            pkg=$(basename "$file" | sed 's/-[^-]*-[^-]*-[^-]*\.pkg\.tar\.zst$//')
            echo "Cleaning old assets for: $pkg"
            gh release view latest --repo ${{ github.repository }} --json assets -q '.assets[].name' | \
              grep "^${pkg}-" | grep -E '\.(pkg\.tar\.zst|sig)$' | while read -r asset; do
                gh release delete-asset latest "$asset" --repo ${{ github.repository }} --yes
              done
          done

          # Upload files
          gh release upload latest repo/* --repo ${{ github.repository }} --clobber

      - name: Check for build failures
        if: steps.build.outputs.failed != ''
        run: |
          echo "::error::The following packages failed to build:${{ steps.build.outputs.failed }}"
          exit 1
